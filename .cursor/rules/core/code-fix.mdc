---
description: fix bug,bug,修复,报错
globs: 
alwaysApply: false
---
使用系统化、验证驱动的方法诊断和解决问题：

1. **收集详细上下文**：
   - 收集所有相关细节：错误消息、日志、堆栈跟踪和与问题相关的观察到的行为。
   - 使用 `grep_search` 查找精确术语（例如，函数名）或使用 `file_search` 查找更广泛的上下文，以确定受影响的文件和依赖项。
   - 追踪数据流或执行路径以定义问题的边界——映射输入、输出和交互。

2. **排查根本原因**：
   - 列出至少三个可能的原因，涵盖代码逻辑、依赖项或配置——例如，"未定义变量"、"缺失导入"、"API 超时"。
   - 使用 `cat -n <文件路径>` 检查带行号的代码，使用 `tree -L 4 --gitignore | cat` 检查相关文件来验证每个原因。
   - 通过交叉引用执行路径和依赖链来确认或排除假设。

3. **复用现有模式**：
   - 使用 `file_search` 搜索代码库中已解决的类似问题或修复。
   - 识别符合项目约定的可重用工具或错误处理策略——避免重新发明解决方案。
   - 根据当前问题的具体情况验证重用候选方案以确保相关性。

4. **分析影响**：
   - 追踪所有受影响的依赖项（例如，导入、调用、外部服务）以评估问题的范围。
   - 确定是局部错误还是更广泛设计缺陷的症状——例如，"紧密耦合"或"缺少错误处理"。
   - 强调问题和建议修复对性能或可维护性的潜在副作用。

5. **提出针对性修复**：
   - 建议具体、最小化的更改——提供文件路径（相对于工作区根目录）、行号和代码片段。
   - 用清晰的推理证明每个修复，将其与稳定性、可重用性或系统一致性联系起来——例如，"添加空值检查防止崩溃"。
   - 除非明确要求，否则避免广泛重构；专注于高效解决问题。

6. **验证和监控**：
   - 概述测试用例——正常、边缘和失败场景——以验证修复（例如，"使用空输入测试"）。
   - 推荐验证方法：单元测试、手动检查或日志——根据项目设置定制。
   - 建议添加日志或指标（例如，"在第 Y 行记录错误 X"）以跟踪复发并确认解决。

此过程确保彻底、高效的解决方案，在直接解决报告问题的同时加强代码库。